(()=>{"use strict";class t{constructor(t=null,e=null){this.value=t,this.nextNode=e}}const e=new class{constructor(){this.head=null,this.tail=null}append(e){let n=new t(e);this.head?(this.tail.nextNode=n,this.tail=n):(this.head=n,this.tail=n)}prepend(e){let n=new t(e);if(this.head){const t=this.head;this.head=n,this.head.nextNode=t}else this.head=n,this.tail=n}size(){let t=this.head,e=0;for(;null!=t;)e++,t=t.nextNode;return e}header(){return Object.values(this.head)[0]}tailer(){return Object.values(this.tail)[0]}at(t){let e=this.head,n=0;for(;t!=n&&null!=e;)n++,e=e.nextNode;return e}pop(){let t=this.head,e=this.head;if(null===t)return"List is empty. nothing to pop";if(this.head===this.tail)return this.head=null,this.tail=null,null;for(;t!=this.tail;)e=t,t=t.nextNode;return e.nextNode=null,this.tail=e,this.head}contains(t){let e=this.head;for(;null!=e;){if(e.value===t)return!0;e=e.nextNode}return!1}find(t){let e=this.head,n=0;for(;null!=e;){if(e.value===t)return n;n++,e=e.nextNode}return-1}toMyString(t=this.head){return null===t?null:`(${t.value}) -> ${this.toMyString(t.nextNode)}`}};e.append("dog"),e.append("cat"),e.append("mouse"),e.prepend("anteloped"),e.append("kitten"),e.append("dear"),e.append("zebra"),e.append("lion"),console.log(e.toMyString())})();